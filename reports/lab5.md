# ch8 实验实现总结
1：mutex的死锁检测很简单，测试中只是单个线程多次获取同一个锁。所以我在mutex_list中改了它 Option的内容，是一个元组tuple，我把获取锁的线程 tid 和这个锁绑定。初始化的时候设置这个tid为usize的最大值。获取锁的时候如果进程死锁检测，那么判断tid和当前tid的关系。释放锁的时候会重置和锁有关的tid为usize的最大值。

2：银行家算法的实现很奇怪，这里做简单记录。
我只做了两个数组，一个是need数组，它大小为n*m，一个是finished数组，它大小为线程数目。

finish数组需要在sys_fork中设置finish，给他压入一个false，因为进程初始化会有一个初始线程。

在exit_current_run_next函数中，需要设置当前task的finish数组为true。任务已完成。

同时，在sys_thread_create 的时候，新建线程，这时候finished数组压入一个false。同时给当前线程在need数组中添加位置。这时候需要判断当前进程是否有信号量，如果有，那么信号量的数量是need数组[0]的长度。否则，信号量数量为0。这时候初始化一个零向量，长度为信号量的数量，压入need数组，即可。

同时，在新建信号量的时候：如果need矩阵为空，说明进程当前没有信号量，这时候，根据测试用例，是0号线程在新建，别的线程还没建立，需要need矩阵先给压入一个Vec::new()。表示给0号线程压入信号量需求矩阵。

随后给need矩阵的[0]中压入0，代表，当前0号线程对该信号量的需求为 0。

sys_semaphore_up函数中对于finish的操作，只需设置当前tid的finish数组为true。

sys_semaphore_down函数先设置need矩阵的[tid][sem_id] += 1，即当前线程对于该sem_id对应的信号量需求加1。随后开始遍历，筛选掉已经finish的任务，遍历所有还没finish的任务，观察他们的need矩阵。这时存在的所有未完成任务，他们可能需求并非这个sem，那么他们对这个sem的need为0，如果他们需求当前任务，那么他们对sem的需求为1。只可能是这两种情况吗？应该是。其实就是做一个预防这样。如果当前可用资源不满足对sem有需求的所有任务，那么资源不足，可能造成死锁这样？返回错误。

这其实相当于在每次申请资源的时候，考虑该资源的余量能否满足正在等待该资源的task以及当前需求的总和。不满足就返回错误吗？大概是这样。

感觉实现有点牵强。但还是过了?

sys_semaphore_down函数的最后需要need矩阵[tid][sem_id] -= 1，因为如果没有资源down掉会block切别的task，那么这时候再调度回来已经拥有资源了，所以，减去需求即可。这里我明白。但是最终实现是有点奇怪。

# 问答作业
## 当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。
首先需要把所有子进程挂在initproc之下。

回收所有子线程的 tid，trap_cx和u_stack。

## 对比以下两种 Mutex.unlock 的实现，二者有什么区别？这些区别可能会导致什么问题？

第二种我觉得更好，因为保证了从任务出队列到释放锁这一过程是原子的。
第一种情况直接释放锁，再任务出队，会可能导致任务出队之后抢占，获取锁，进而任务切回来再释放锁。导致未知问题。
